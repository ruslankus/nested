<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1251">
 <title>ƒерево каталогов NESTED SETS (вложенные множества) и управление им / ѕечатна€ верси€ / GetInfo.Ru -  омпьютерна€ библиотека</title>
 <meta name="description" content="$anonce">
 <meta name="keywords" content="">
 <link rel="stylesheet" type="text/css" href="article610_files/getinfo.css">
</head>

<body topmargin="0" bottommargin="0" leftmargin="0" rightmargin="0" bgcolor="#FFFFFF" marginheight="0" marginwidth="0">

<table align="center" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr>
<td bgcolor="#E8A11A"><a href="http://www.getinfo.ru/"><img src="article610_files/popup_logo.gif" alt="GetInfo.Ru -  омпьютерна€ библиотека" border="0" height="55" width="182"></a></td>
<td class="addheader" align="right" bgcolor="#E8A11A">¬≈–—»я ƒЋя ѕ≈„ј“»&nbsp;&nbsp;&nbsp;</td>
</tr>
</tbody></table>

<!-- Ќачало блока текста статьи -->
<table align="center" border="0" cellpadding="3" cellspacing="2" width="97%">
<tbody><tr>
<td align="center" valign="top"><span class="doctitle">ƒерево каталогов NESTED SETS (вложенные множества) и управление им</span>
<br><a href="http://www.getinfo.ru/author309.html" class="docauthor">—ергей “омулевич</a>
<br><a class="docauthor" href="mailto:phoinix@asit.ru">phoinix@asit.ru</a>

<br><br><div align="right"><font class="docpages">—траницы: </font></div>
<br><img src="article610_files/spacer.gif" height="5" width="1"></td>
</tr><tr>
<td valign="top"><p class="doctext" align="justify">ќ проблемах хранени€ деревьев в SQL базах данных вопрос можно не поднимать, просто сказать, что они есть. </p>
<p>ѕрежде всего посмотрим, как выгл€д€т деревь€ Nested Sets, как они организованы и в чем удобство их использовани€.</p>
<div align="center"><img src="article610_files/610-1.gif" alt="" height="242" width="370"></div>
<p>Ќа схеме представлено дерево, описанное по всем правилам метода 
"¬ложенных множеств".  вадратами обозначены узлы дерева, синие цифры в 
верхнем правом и верхнем левом углах узла - уровень и уникальный 
идентификатор соответственно, а красные цифры в нижних углах - это левый
 и правый ключ. »менно в этих двух цифрах - левом и правом ключе 
заложена вс€ информаци€ о дереве. » если информацию о ключах занести в 
базу данных, то работа с деревом намного упрощаетс€. ќбратите внимание 
на то, в каком пор€дке проставлены эти ключи. ≈сли мысленно пройтись по 
пор€дку от 1 до 32, то вы обойдете все узлы дерева слева направо. 
‘актически это путь обхода всех узлов дерева слева направо.</p>
<p>ѕри использовании такой структуры дерева каталогов, очень сильно 
упрощаетс€ выборка определенных элементов, таких как родительска€ ветка,
 подчиненные узлы, вообще вс€ "ветка" в которой участвует наш узел. ¬ 
общем все гораздо проще увидеть на практике: </p>
<p>—оздадим таблицу, где мы будем хранить наше дерево:</p>
<p><strong><font color="#0000FF">CREATE</font> my_tree</strong> (<br>
  <strong>id </strong><font color="#FF00FF">INT</font>(10) <strong><font color="#0000FF">NOT NULL</font> </strong><font color="#FF00FF">AUTO_INCREMENT</font>,<br>
  <strong>name</strong> <font color="#FF00FF">VARCHAR</font>(150) <strong><font color="#0000FF">NOT NULL</font></strong>,<br>
<strong>left_key </strong><font color="#FF00FF">INT</font>(10)
<strong><font color="#0000FF">NOT NULL DEFAULT</font> </strong>0,<br>
<strong>right_key </strong><font color="#FF00FF">INT</font>(10) <strong><font color="#0000FF">NOT NULL DEFAULT</font></strong> 0,<br>
<strong>level</strong> <font color="#FF00FF">INT</font>(10) NOT <strong><font color="#0000FF">NULL DEFAULT</font></strong> 0,<br>
<strong><font color="#0000FF">PRIMARY KEY</font> id</strong>,<br>
<strong><font color="#0000FF">INDEX</font> left_key</strong> (<strong>left_key</strong>, <strong>right_key</strong>, <strong>level</strong>) <br>
) </p>
<p>“еперь определим, какие данные мы можем из неЄ (таблицы) выбрать:</p>
<p>1. —обственно само дерево:</p>
<p><strong><font color="#0000FF">SELECT </font>id</strong>, <strong>name</strong>, <strong>level <font color="#0000FF">FROM</font> my_tree <font color="#0000FF">ORDER BY</font> left_key</strong></p>
<p>¬ итоге, после небольшой обработки (в которой<em> level</em> играет роль множител€ отступа), получим следующий список: </p>
<p>Х ”зел 1<br>
 Х Х ”зел 2<br>
Х Х Х ”зел 5<br>
Х Х Х Х ”зел 10<br>
Х Х Х Х ”зел 11<br>
Х Х ”зел 3 <br>
Х Х Х ”зел 6<br>
Х Х Х ”зел 7 <br>
Х Х Х Х ”зел 12<br>
Х Х Х Х ”зел 13<br>
Х Х Х Х ”зел 14<br>
Х Х Х ”зел 8<br>

Х Х ”зел 4 <br>
Х Х Х ”зел 9 <br>
Х Х Х Х ”зел 15<br>
Х Х Х Х ”зел 16</p>
<p>2. ¬ыбор подчиненных узлов (за отправной узел возьмем "”зел 7" его ключи <font color="#FF6600">$left_key</font>, <font color="#FF6600">$right_key</font> и уровень <font color="#FF6600">$level</font>) </p>
<p><strong><font color="#0000FF">SELECT </font>id</strong>, <strong>name</strong>, <strong>level <font color="#0000FF">FROM</font> my_tree <font color="#0000FF">WHERE </font>left_key &gt;= </strong><font color="#FF6600">$left_key</font><strong> <font color="#0000FF">AND </font>right_key &lt;= </strong><font color="#FF6600">$right_key</font><strong> <font color="#0000FF">ORDER BY</font> left_key</strong></p>
<p>¬ итоге получаем:</p>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
  <tbody><tr>
    <td width="30%">Х Х Х ”зел 7 <br>
Х Х Х Х ”зел 12<br>
Х Х Х Х ”зел 13<br>
Х Х Х Х ”зел 14</td>
    <td><div align="left"><img src="article610_files/610-2.gif" alt="" height="117" width="159"></div></td>
  </tr>
</tbody></table>
<p>3. ¬ыбор родительской "ветки": </p>
<p><strong><font color="#0000FF">SELECT </font>id</strong>, <strong>name</strong>, <strong>level <font color="#0000FF">FROM</font> my_tree <font color="#0000FF">WHERE </font>left_key &lt;= </strong><font color="#FF6600">$left_key</font><strong> <font color="#0000FF">AND </font>right_key &gt;= </strong><font color="#FF6600">$right_key</font><strong> <font color="#0000FF">ORDER BY</font> left_key</strong></p>
<p>¬ итоге получаем:</p>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
  <tbody><tr>
    <td width="30%">Х ”зел 1 <br>
      Х Х ”зел 3 <br>
      Х Х Х ”зел 7</td>
    <td><div align="left"><img src="article610_files/610-3.gif" alt="" height="177" width="52"></div></td>
  </tr>
</tbody></table>
<p>4. ¬ыбор ветки в которой участвует наш узел:</p>
<p><strong><font color="#0000FF">SELECT </font>id</strong>, <strong>name</strong>, <strong>level <font color="#0000FF">FROM</font> my_tree <font color="#0000FF">WHERE </font>right_key &gt; </strong><font color="#FF6600">$left_key</font><strong> <font color="#0000FF">AND </font>left_key &lt; </strong><font color="#FF6600">$right_key</font><strong> <font color="#0000FF">ORDER BY</font> left_key</strong></p>
<p>¬ итоге получаем:</p>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
  <tbody><tr>
    <td width="30%">Х ”зел 1<br>
Х Х ”зел 3 <br>
Х Х Х ”зел 7 <br>
Х Х Х Х ”зел 12<br>
Х Х Х Х ”зел 13<br>
Х Х Х Х ”зел 14</td>
    <td><div align="left"><img src="article610_files/610-4.gif" alt="" height="242" width="158"></div></td>
  </tr>
</tbody></table>
<p></p>
<p>¬ общем использование в условии запроса ключи узла можно выбрать любые данные св€занные с этим узлом. </p>
<p>≈динственным затруднением может возникнуть выборка родительского узла, чтобы его получить можно сделать запрос: </p>
<p><strong><font color="#0000FF">SELECT </font>id</strong>, <strong>name</strong>, <strong>level <font color="#0000FF">FROM</font> my_tree <font color="#0000FF">WHERE </font>left_key &lt;= </strong><font color="#FF6600">$left_key</font><strong> <font color="#0000FF">AND </font>right_key &gt;= </strong><font color="#FF6600">$right_key</font><strong> <font color="#0000FF">AND </font>level = </strong><font color="#FF6600">$level </font>+ 1  <strong><font color="#0000FF">ORDER BY</font> left_key</strong></p>
<p>ѕравда, такой метод может показатьс€ довольно громоздким, поэтому, 
дл€ удобства, часто добавл€ют уще одно поле в таблицу - parent_id - в 
котором хранитс€ идентификатор родительского узла. </p>
<p><strong>”правление деревом каталогов</strong><br>
ѕрежде чем начинать управл€ть деревом, создадим проверку целостности 
ключей, что бы линий раз не наступать на Ђграблиї. ƒл€ этого определим 
основные правила:</p>
<p>
1. Ћевый ключ <em>¬—≈√ƒј</em> меньше правого;<br>
2. Ќаименьший левый ключ <em>¬—≈√ƒј </em>равен 1;<br>
3. Ќаибольший правый ключ <em>¬—≈√ƒј </em>равен двойному числу узлов;<br>
4. –азница между правым и левым ключом <em>¬—≈√ƒј </em>нечетное число;<br>
5. ≈сли уровень узла нечетное число то тогда левый ключ <em>¬—≈√ƒј </em>нечетное число, то же самое и дл€ четных чисел;<br>
6.  лючи <em>¬—≈√ƒј </em>уникальны, вне зависимости от того правый он или левый;</p>
<p>ќтсюда, создаем проверочные запросы : </p>
<p>1. <strong> <font color="#0000FF">SELECT</font> id <font color="#0000FF">FROM</font> my_tree <font color="#0000FF">WHERE</font> left_key</strong> &gt;= <strong>right_key</strong></p>
<p>≈сли все правильно то результата работы запроса не будет, иначе, получаем список идентификаторов неправильных строк;</p>

<p> 2 (3). <strong><font color="#0000FF">SELECT</font></strong> <font color="#FF00FF">COUNT</font>(<strong>id</strong>), <font color="#FF00FF">MIN</font>(<strong>left_key</strong>), <font color="#FF00FF">MAX</font>(<strong>right_key</strong>) <strong><font color="#0000FF">FROM </font>my_tree</strong></p>
<p>ѕолучаем количество записей (узлов), минимальный левый ключ и максимальный правый ключ, провер€ем значени€. </p>
<p> 4. <strong><font color="#0000FF">SELECT</font> id</strong>, <font color="#FF00FF">MOD</font>((<strong>right_key</strong> - <strong>left_key</strong>) / 2) <strong> <font color="#0000FF">AS</font> ostatok <font color="#0000FF">FROM</font> my_tree <font color="#0000FF">WHERE</font> ostatok</strong> = 0 </p>
<p>≈сли все правильно то результата работы запроса не будет, иначе, получаем список идентификаторов неправильных строк;</p>
<p>5.  <strong><font color="#0000FF">SELECT</font> id</strong>, <font color="#FF00FF">MOD</font>((<strong>left_key</strong> Ц <strong>level </strong>+ 2) / 2)  <strong><font color="#0000FF">AS</font> ostatok <font color="#0000FF">FROM</font> my_tree <font color="#0000FF">WHERE</font> ostatok </strong>= 1 </p>
<p>≈сли все правильно то результата работы запроса не будет, иначе, получаем список идентификаторов неправильных строк;</p>
<p>6.  <strong><font color="#0000FF">SELECT </font>t1.id</strong>, <font color="#FF00FF">COUNT</font>(<strong>t1.id</strong>)  <strong><font color="#0000FF">AS</font> rep</strong>, <font color="#FF00FF">MAX</font>(<strong>t3.right_key</strong>)  <strong><font color="#0000FF">AS</font> max_right <font color="#0000FF">FROM</font> my_tree <font color="#0000FF">AS</font> t1</strong>, <strong>my_tree <font color="#0000FF">AS</font> t2</strong>, <strong>my_tree <font color="#0000FF">AS</font> t3 <font color="#0000FF">WHERE</font> t1.left_key </strong>&lt;&gt; <strong>t2.left_key <font color="#0000FF">AND</font> t1.left_key </strong>&lt;&gt; <strong>t2.right_key <font color="#0000FF">AND</font> t1.right_key </strong>&lt;&gt; <strong>t2.left_key <font color="#0000FF">AND</font> t1.right_key </strong>&lt;&gt; <strong>t2.right_key <font color="#0000FF">GROUP BY</font>  t1.id <font color="#0000FF">HAVING</font> max_right </strong>&lt;&gt; <font color="#FF00FF">SQRT</font>(4 * <strong>rep </strong>+ 1) + 1 </p>
<p>«десь, € думаю, потребуетс€ некоторое по€снение запроса. ¬ыборка по сути осуществл€етс€ из одной таблицы, но в разделе <em>FROM </em>эта
 таблица "виртуально" продублирована 3 раза: из первой мы выбираем все 
записи по пор€дку и начинаем сравнивать с запис€ми второй таблицы 
(раздел <em>WHERE</em>) в результате мы получаем все записи 
неповтор€ющихс€ значений. ƒл€ того, что бы определить сколько раз запись
 не повтор€лась в таблице, производим группировку (раздел <em>GROUP BY</em>) и получаем число "не повторов" (<em>COUNT(t1.id)</em>).
 ѕо условию, если все ключи уникальны, то число не повторов будет меньше
 на одну единицу чем общее количество записей. ƒл€ того, чтобы 
определить количество записей в таблице, берем максимальный правый ключ 
(MAX(t3.right_key)), так как его значение - двойное число записей, но 
так как в условии отбора дл€ записи с максимальным правым ключом - 
максимальный правый ключ будет другим, вводитс€ треть€ таблица, при этом
 число "неповторов" увеличиваетс€ умножением его на количество записей. <em>SQRT(4*rep +1)</em> - решение уравнени€ <em>x^2 + x = rep</em>. ≈сли все правильно то результата работы запроса не будет, иначе, получаем список идентификаторов неправильных строк;</p>
<p><font color="#999999">ѕримечание: ’от€ данное тестирование не дает 100% гарантии, но определит большее количество ошибок.</font></p>
<p><strong>—оздание узла</strong><br>
—оздание узла Ц самое простое действие над деревом. ƒл€ того, что бы его
 осуществить нам потребуетс€ уровень и правый ключ родительского узла 
(узел в который добавл€етс€ новый), либо максимальный правый ключ, если у
 нового узла не будет родительского.</p>
<p>ѕусть <font color="#FF6600">$right_ key</font> Ц правый ключ 
родительского узла, или максимальный правый ключ плюс единица (если 
родительского узла нет, то узел с максимальным правым ключом не будет 
обновл€тьс€, соответственно, чтобы не было повторов, берем число на 
единицу большее). <font color="#FF6600">$level</font> Ц уровень родительского узла, либо 0, если родительского нет.</p>
<p>1. ќбновл€ем ключи существующего дерева, узлы сто€щие за родительским узлом:</p>
<p><strong><font color="#0000FF">UPDATE</font> my_tree <font color="#0000FF">SET</font> left_key</strong> = <strong>left_key </strong>+ 2, <strong>right_ key </strong>= <strong>right_ key </strong>+ 2 <strong><font color="#0000FF">WHERE</font> left_key </strong>&gt; <font color="#FF6600">$right_ key</font> </p>
<p>Ќо мы обновили только те узлы в которых измен€ютс€ оба ключа, при 
этом родительскую ветку (не узел, а все родительские узлы) мы не 
трогали, так как в них измен€етс€ только правый ключ. —ледует иметь в 
виду, что если у нас не будет родительского узла, то есть новый узел 
будет корневым, то данное обновление проводить нельз€.</p>
<p>2. ќбновл€ем родительскую ветку:</p>
<p><strong><font color="#0000FF">UPDATE</font> my_tree <font color="#0000FF">SET</font> right_key</strong> = <strong>right_key </strong>+ 2 <strong><font color="#0000FF">WHERE</font> right_key </strong>&gt;= <font color="#FF6600">$right_key</font> <strong><font color="#0000FF">AND</font> left_key </strong>&lt; <font color="#FF6600">$right_key</font> </p>
<p>3. “еперь добавл€ем новый узел : </p>
<p><strong><font color="#0000FF">INSERT INTO</font> my_tree <font color="#0000FF">SET</font> left_key </strong>= <font color="#FF6600">$right_key</font>, <strong>right_key</strong> = <font color="#FF6600">$right_key</font> + 1, <strong>level </strong>= <font color="#FF6600">$level</font> + 1 [дополнительные параметры ] </p>
<p>4. ѕровер€ем.</p>
<p>“еперь можно объединить первые два запроса в один, что бы не делать лишних действий. </p>
<p><strong><font color="#0000FF">UPDATE</font> my_tree <font color="#0000FF">SET</font> 
  right_key</strong> = <strong>right_key </strong>+ 2, <strong>  left_key</strong> = <strong><font color="#0000FF">IF</font></strong>(<strong>left_key </strong>&gt; <font color="#FF6600">$right_key</font>,<strong> left_key</strong> + 2, <strong>left_key</strong>) 
<strong><font color="#0000FF">WHERE</font> right_key </strong>&gt;= <font color="#FF6600">$right_key</font> </p>
<p><strong>”даление узла</strong><br>
”даление узла не намного сложнее, но требуетс€ учесть, что у удал€емого 
узла могут быть подчиненные узлы. ƒл€ осуществлени€ этого действи€ нам 
потребуетс€ левый и правый ключ удал€емого узла.</p>
<p>ѕусть <font color="#FF6600">$left_key </font>Ц левый ключ удал€емого узла, а <font color="#FF6600">$right_key</font> Ц правый**</p>
<p><font color="#999999">** ѕолучить эти данные не сложно одним простейшим запросом. </font></p>
<p>1. ”дал€ем узел (ветку):</p>
<p><strong><font color="#0000FF">DELETE FROM </font>my_tree <font color="#0000FF">WHERE</font> left_key </strong>&gt;= <font color="#FF6600">$left_key</font> <strong><font color="#0000FF">AND</font> right_ key </strong>&lt;= <font color="#FF6600">$right_key</font> </p>
<p>2. ќбновл€ем ключи оставшихс€ веток:</p>
<p> ак и в случае с добавлением обновление происходит двум€ командами: 
обновление ключей родительской ветки и обновление ключей узлов, сто€щих 
за родительской веткой. —ледует правда учесть, что обновление будет 
производитьс€ в другом пор€дке, так как ключи у нас уменьшаютс€.</p>
<p>2.1. ќбновление родительской ветки : </p>
<p><strong><font color="#0000FF">UPDATE</font> my_tree <font color="#0000FF">SET</font> right_key </strong>= <strong>right_key</strong> Ц (<font color="#FF6600">$right_key</font> - <font color="#FF6600">$left_key</font> + 1)<font color="#999999">***</font> <strong><font color="#0000FF">WHERE</font> right_key</strong> &gt; <font color="#FF6600">$right_key</font> <strong><font color="#0000FF">AND</font> left_key </strong>&lt; <font color="#FF6600">$left_key</font> </p>
<p><font color="#999999">*** “ак как мы не знаем точное количество 
подчиненных узлов, мы вычисл€ем длину диапазона (смещени€) ключей 
удал€емой ветки (узла). </font></p>
<p>2.2. ќбновление последующих узлов : </p>
<p><strong><font color="#0000FF">UPDATE</font> my_tree <font color="#0000FF">SET</font> left_key </strong>= <strong>left_key </strong>Ц (<font color="#FF6600">$right_key</font> - <font color="#FF6600">$left_key</font> + 1), <strong>right_key</strong> = <strong>right_key </strong>Ц (<font color="#FF6600">$right_key</font> - <font color="#FF6600">$left_key</font> + 1) <strong><font color="#0000FF">WHERE</font> left_key</strong> &gt; <font color="#FF6600">$right_key </font></p>
<p>3. ѕровер€ем.</p>
<p>“еперь можно объединить последние два запроса в один, что бы не делать лишних действий. </p>
<p><strong><font color="#0000FF">UPDATE</font> my_tree <font color="#0000FF">SET</font> 
left_key </strong>= <strong><font color="#0000FF">IF</font></strong>(<strong>left_key </strong>&gt; <font color="#FF6600">$left_key</font>, <strong>left_key </strong>Ц (<font color="#FF6600">$right_key</font> - <font color="#FF6600">$left_key</font> + 1), <strong>left_key</strong>),<strong> right_key </strong>= <strong>right_key </strong>Ц (<font color="#FF6600">$right_key</font> - <font color="#FF6600">$left_key</font> + 1) <font color="#0000FF"></font><strong><font color="#0000FF">
WHERE</font> right_key</strong> &gt; <font color="#FF6600">$right_key </font></p>
<p><strong>ѕеремещение узла</strong><br>
ѕеремещение узла Ц самое сложное действие в управлении деревом. Ќа схеме
 показаны области, на которые можно разделить наше дерево. »з еЄ можно 
увидеть, что узел может перемещатьс€ только в две разные области: 
вышесто€щих и нижесто€щих узлов. ¬ообще, чем примечательно использование
 Nested Set, что с помощью двух ключей ветки возможен выбор узлов любой 
области. </p>
<div align="center"><img src="article610_files/610-5.gif" alt="" height="281" width="380"></div>
<p>1. ¬верх по дереву (в область вышесто€щих узлов), включает в себ€:</p>
<ul type="square">
<li>ѕеренос ветки (узла) в подчинение нижесто€щему по дереву узлу;
</li><li>ѕеренос ветки (узла) вверх без изменени€ родительского узла (изменение пор€дка узлов); </li></ul>

<p>2. ¬низ по дереву (в область нижесто€щих узлов), включает в себ€.</p>
<ul type="square">
  <li>ѕеренос ветки в Ђкореньї дерева (учитыва€, что переносима€ ветка будет последней по пор€дку); </li>
  <li>ѕеренос ветки (узла) вниз без изменени€ родительского узла (изменение пор€дка узлов); </li>
  <li>ѕодн€тие узла (ветки) на уровень выше; </li>
  <li>ѕеремещение ветки вниз по дереву:</li>
</ul>
<p>ƒл€ начала выберем ключи следующих узлов:</p>
<p>1.  лючи и уровень перемещаемого узла;</p>
<p> <strong><font color="#0000FF">SELECT </font>level, left_key, right_key <font color="#0000FF">FROM</font> my_tree <font color="#0000FF">WHERE</font> id </strong>= <font color="#FF6600">$id</font> </p>
  <p>ѕолучаем <font color="#FF6600">$level</font>, <font color="#FF6600">$left_key</font>, <font color="#FF6600">$right_key</font> </p>
  <p>2. ”ровень нового родительского узла (если узел перемещаетс€ в "корень" то сразу можно подставить значение 0):</p>
  <p><strong><font color="#0000FF">SELECT </font>level <font color="#0000FF">FROM</font> my_tree <font color="#0000FF">WHERE</font> id </strong>= <font color="#FF6600">$id_up</font></p>
  <p>ѕолучаем <font color="#FF6600">$level_up</font></p>
  <p>3. ѕравый ключ узла за который мы вставл€ем узел (ветку):</p>
  <p>ƒанный параметр, а не ключи нового родительского узла, выбираем по 
одной простой причине: ƒл€ обычного перемещени€ этого ключа нам будет 
достаточно, а при изменении пор€дка узлов и переноса в "корень" дерева 
данный параметр нам просто необходим.</p>
  <p>ƒанна€ переменна€ беретс€ в зависимости от действи€:</p>
  <ul type="square">
    <li>ѕри простом перемещении в другой узел;</li>
  </ul>
  <p> <strong><font color="#0000FF">SELECT</font></strong> (<strong>right_key</strong> Ц 1) <strong><font color="#0000FF">AS</font> right_key <font color="#0000FF">FROM</font> my_tree <font color="#0000FF">WHERE</font> id</strong> = <font color="#FF6600">[id нового родительского узла] </font></p>
  <ul type="square">
    <li>ѕри изменении пор€дка, когда родительский узел не мен€етс€ Ц правый ключ узла за которым будет сто€ть перемещаемый; </li>
  </ul>
  <p> <strong><font color="#0000FF">SELECT</font> left_key, right_key <font color="#0000FF">FROM</font> my_tree <font color="#0000FF">WHERE</font> id </strong>= <font color="#FF6600">[id соседнего узла с который будет(!) выше (левее)]<font color="#999999">****</font></font></p>
  <p><font color="#999999">**** —ледует обратить внимание, что при 
подн€тии узла вверх по пор€дку, узел выбираетс€ не соседний, а 
следующий, за неимением оного (перемещаемый узел будет первым) беретс€ 
левый ключ родительского узла </font></p>
  <ul type="square"><li>ѕри переносе узла в корень дерева Ц максимальный правый ключ ветки; </li>
  </ul>
  <p> <strong><font color="#0000FF">SELECT</font> </strong><font color="#FF00FF">MAX</font>(<strong>right_key</strong>) <strong><font color="#0000FF">FROM</font> my_tree </strong></p>
  <ul type="square">
    <li>ѕри подн€тии узла на уровень выше Ц правый ключ старого родительского узла</li>
  </ul>
  <p> <strong><font color="#0000FF">SELECT </font>right_key <font color="#0000FF">FROM</font> my_tree <font color="#0000FF">WHERE</font> level </strong>= <font color="#FF6600">$level</font> </p>
  <p>ѕолучаем <font color="#FF6600">$right_key_near</font> и <font color="#FF6600">$left_key_near</font> (дл€ варианта изменени€ пор€дка)</p>
  <p>4. ќпредел€ем смещени€:</p>
  <ul type="square">
    <li><font align="justify" color="#FF6600">$level_up</font> - <font color="#FF6600">$level </font>+ 1 = <font color="#FF6600">$skew_level</font> - смещение уровн€ измен€емого узла;</li>
    <li><font align="justify" color="#FF6600">$right_key</font> - <font color="#FF6600">$left_key</font> + 1 = <font color="#FF6600">$skew_tree</font> - смещение ключей дерева;</li>
  </ul>
  <p>¬ыбираем все узлы перемещаемой ветки:</p>
  <p><strong><font color="#0000FF">SELECT</font> id <font color="#0000FF">FROM</font> my_tree <font color="#0000FF">WHERE</font> left_key </strong>&gt;= <font color="#FF6600">$left_key</font> <strong><font color="#0000FF">AND</font> right_key </strong>&lt;= <font color="#FF6600">$right_key</font> </p>
  <p>ѕолучаем <font color="#FF6600">$id_edit</font> - список id номеров перемещаемой ветки. </p>
  <p>“ак же  требуетс€ определить: в какую область перемещаетс€ узел, дл€ этого сравниваем <font color="#FF6600">$right_key</font> и <font color="#FF6600">$right_key_near</font>, если <font color="#FF6600">$right_key_near</font> больше, то узел перемещаетс€ в облась вышесто€щих узлов, иначе - нижесто€щих (почему существует разделение описано ниже).</p>
  <p>√де у нас измен€ютс€ ключи по дереву во врем€ переноса узла показано на схеме:</p>
<div align="center"><img src="article610_files/610-6.gif" alt="" height="169" width="404"></div>
  <p> ак видно из схемы правые ключи мен€ютс€ только у левой 
родительской ветки, левые ключи мен€ютс€ у правой родительской ветки а 
оба ключа мен€ютс€ в узлах наход€щихс€ между родительской старой и 
родительской новой веткой, области изменений, не мен€ютс€ в зависимости 
от того, в какую (вышесто€щую или нижесто€щую) область перемещаетс€ 
узел. ќтличием €вл€етс€, то что при перемещении в вышесто€щую область 
ключи увеличиваютс€, а при переходе в нижесто€щую - уменьшаютс€.</p>
  <p>’очу обратить внимание на то что у нас есть разница изменени€ 
ключей дерева в зависимости от того, в какую область перемещаетс€ узел 
(увеличение &lt;-&gt; уменьшение), а так же то, что права€ родительска€ 
ветка может быть как старой, так и новой родительской веткой, то же 
самое и с левой родительской веткой. ѕоэтому пор€док обновлени€ ключей и
 услови€ выбора диапазонов областей различны, в зависимости от вида 
перемещени€ (вверх или вниз).</p>
  <p>¬озможно обновление ключей в три этапа: кажда€ ветка отдельно и 
диапазон между ними. Ќо так как мы мен€ем только два ключа, причем 
изменение на одно и то же число, то можно обойтись и двум€ командами (<em>UPDATE</em>). </p>
  <p>ѕри перемещении вверх по дереву выдел€ем следующие области:</p>
  <ul type="square">
    <li>ƒл€ левого ключа:
      <ul type="square">
        <li>левый ключ узла меньше <font color="#FF6600">$left_key</font></li>
      <li>левый ключ узла больше <font color="#FF6600">$right_key_near</font></li>
      </ul></li>
  </ul>
<div align="center"><img src="article610_files/610-7.gif" alt="" height="200" width="402"></div>
  <ul type="square">
    <li>ƒл€ правого ключа:
      <ul type="square">
        <li>правый ключ узла меньше <font color="#FF6600">$left_key</font></li>
        <li>правый ключ узла больше <font color="#FF6600">$right_key_near</font></li>
      </ul>
    </li>
  </ul>
<div align="center"><img src="article610_files/610-8.gif" alt="" height="202" width="404"></div>
  <p>’отел бы обратить внимание на то, что в условии с <font color="#FF6600">$right_key_near</font> и <font color="#FF6600">$left_key</font> дерево раздел€етс€ на разные области так как эти переменные сравниваютс€ с разными ключами. </p>
  <p>ќпредел€ем смещение ключей редактируемого узла <font align="justify" color="#FF6600">$right_key_near</font> - <font color="#FF6600">$left_key</font> + 1 = <font color="#FF6600">$skew_edit</font>;</p>
  <p>“ак как при в услови€х не участвуют ключи кроме измен€емых, то пор€док действий не имеет значени€.</p>
  <p>1. <strong><font color="#0000FF">UPDATE </font>my_tree <font color="#0000FF">SET</font> right_key </strong>= <strong>right_key </strong>+ <font color="#FF6600">$skew_tree</font> <strong><font color="#0000FF">WHERE</font> right_key </strong>&lt; <font color="#FF6600">$left_key</font> <strong><font color="#0000FF">AND</font> right_key </strong>&gt; <font color="#FF6600">$right_key_near</font></p>
  <p>2. <strong><font color="#0000FF">UPDATE</font> my_tree <font color="#0000FF">SET</font> left_key </strong>= <strong>left_key </strong>+ <font color="#FF6600">$skew_tree</font> <strong><font color="#0000FF">WHERE</font> left_key </strong>&lt; <font color="#FF6600">$left_key</font> <strong><font color="#0000FF">AND</font> left_key </strong>&gt; <font color="#FF6600">$right_key_near</font></p>
  <p>“еперь можно переместить ветку:</p>
  <p><strong><font color="#0000FF">UPDATE</font> my_tree <font color="#0000FF">SET</font> left_key </strong>= <strong>left_key </strong>+ <font color="#FF6600">$skew_edit</font>, <strong>right_key </strong>=<strong> right_key</strong> + <font color="#FF6600">$skew_edit</font>, <strong>level</strong> =<strong> level</strong> + <font color="#FF6600">$skew_level</font> <strong><font color="#0000FF">WHERE</font> id <font color="#0000FF">IN</font> </strong>(<font color="#FF6600">$id_edit</font>) </p>
  <p>ѕосле оптимизации этих запросов получаем всего один: </p>
<p><strong><font color="#0000FF">UPDATE</font> my_table <font color="#0000FF"><br>
  SET</font> right_key </strong>= <strong><font color="#0000FF">IF</font></strong>(<strong>left_key </strong>&gt;= <font color="#FF6600">$left_key</font>, <strong>right_key </strong>+ <font color="#FF6600">$skew_edit</font>, <strong><font color="#0000FF">IF</font></strong>(<strong>right_key</strong> &lt; <font color="#FF6600">$left_key</font>, <strong>right_key </strong>+ <font color="#FF6600">$skew_tree</font>, <strong>right_key</strong>)),
    <strong><br>
    level </strong>= <strong><font color="#0000FF">IF</font></strong>(<strong>left_key</strong> &gt;= <font color="#FF6600">$left_key</font>, <strong>level </strong>+ <font color="#FF6600">$skew_level</font>, <strong>level</strong>),
    <strong><br>
    left_key </strong>= <strong><font color="#0000FF">IF</font></strong>(<strong>left_key</strong> &gt;= <font color="#FF6600">$left_key</font>, <strong>left_key </strong>+ <font color="#FF6600">$skew_edit</font>, <strong><font color="#0000FF">IF</font></strong>(<strong>left_key </strong>&gt; <font color="#FF6600">$right_key_near</font>, <strong>left_key </strong>+ <font color="#FF6600">$skew_tree</font>, <strong>left_key</strong>))
<strong><font color="#0000FF"><br>
WHERE </font>right_key</strong> &gt; <font color="#FF6600">$right_key_near </font><strong><font color="#0000FF">AND </font>left_key </strong>&lt; <font color="#FF6600">$right_key</font></p>
  <p>¬ данной команде особое внимание нужно уделить пор€дку изменени€ 
полей таблицы, самым последним полем должно измен€тьс€ поле левого ключа
 (<em>left_key</em>), так как его значение €вл€етс€ условием дл€ изменени€ других полей. </p>
  <p>«амечу, что при использовании этой команды, выбирать узлы перемещаемой ветки не нужно.</p>
  <p>ѕри перемещении вниз по дереву выдел€ем следующие области:</p>
  <ul type="square">
    <li>ƒл€ левого ключа:
        <ul type="square">
          <li>левый ключ узла больше <font color="#FF6600">$right_key</font></li>
          <li>левый ключ узла меньше <font color="#FF6600">$right_key_near</font></li>
        </ul>
    </li>
  </ul>
<div align="center"><img src="article610_files/610-9.gif" alt="" height="199" width="404"></div>
  <ul type="square">
    <li>ƒл€ правого ключа:
        <ul type="square">
          <li>правый ключ узла больше <font color="#FF6600">$right_key</font></li>
          <li>правый ключ узла меньше или равно <font color="#FF6600">$right_key_near</font></li>
        </ul>
    </li>
  </ul>
<div align="center"><img src="article610_files/610-10.gif" alt="" height="200" width="404"></div>
  <p>ќп€ть же пор€док не имеет значени€, поэтому просто делаем команды 
на обновление. ѕравда хочу обратить внимание на тот факт, что в условии:
 "<em>левый ключ узла меньше <font color="#FF6600">$right_key_near</font></em>" узел в котором находитс€ <font color="#FF6600">$right_key_near</font>
 тоже попадает в диапазон изменени€, следует иметь ввиду, что при 
сравнении не однотипных ключей (правый &lt;-&gt; левый) текущий узел 
попадает или не попадает в диапазон без использовани€ равенства в 
условии.</p>
  <p>ќпредел€ем смещение ключей редактируемого узла <font align="justify" color="#FF6600">$right_key_near</font> - <font color="#FF6600">$left_key</font> + 1 -  <font color="#FF6600">$skew_tree</font> = <font color="#FF6600">$skew_edit</font>.</p>
  <p>1. <strong><font color="#0000FF">UPDATE </font>my_tree <font color="#0000FF">SET</font> right_key </strong>= <strong>right_key </strong>- <font color="#FF6600">$skew_tree</font> <strong><font color="#0000FF">WHERE</font> right_key </strong>&gt; <font color="#FF6600">$right_key</font> <strong><font color="#0000FF">AND</font> right_key </strong>&lt;= <font color="#FF6600">$right_key_near</font></p>
  <p>2. <strong><font color="#0000FF">UPDATE</font> my_tree <font color="#0000FF">SET</font> left_key </strong>= <strong>left_key </strong>- <font color="#FF6600">$skew_tree</font> <strong><font color="#0000FF">WHERE</font> left_key </strong>&lt; <font color="#FF6600">$left_key</font> <strong><font color="#0000FF">AND</font> left_key </strong>&gt; <font color="#FF6600">$right_key_near</font></p>
  <p>“еперь можно переместить ветку:</p>
  <p><strong><font color="#0000FF">UPDATE</font> my_tree <font color="#0000FF">SET</font> left_key </strong>= <strong>left_key </strong>+ <font color="#FF6600">$skew_edit</font>, <strong>right_key </strong>=<strong> right_key</strong> + <font color="#FF6600">$skew_edit</font>, <strong>level</strong> =<strong> level</strong> + <font color="#FF6600">$skew_level</font> <strong><font color="#0000FF">WHERE</font> id <font color="#0000FF">IN</font> </strong>(<font color="#FF6600">$id_edit</font>) </p>
  <p>ѕосле оптимизации этих запросов получаем всего один: </p>
  <p><strong><font color="#0000FF">UPDATE </font>my_table <font color="#0000FF"><br>
  SET </font>left_key </strong>= <strong><font color="#0000FF">IF</font></strong>(<strong>right_key</strong> &lt;= <font color="#FF6600">$right_key</font>, <strong>left_key </strong>+ <font color="#FF6600">$skew_edit</font>, <strong><font color="#0000FF">IF</font></strong>(<strong>left_key </strong>&gt; <font color="#FF6600">$right_key</font>, <strong>left_key </strong>- <font color="#FF6600">$skew_tree</font>, <strong>left_key</strong>)),
<strong><br>
level </strong>= <strong><font color="#0000FF">IF</font></strong>(<strong>right_key </strong>&lt;= <font color="#FF6600">$right_key</font>, <strong>level </strong>+ <font color="#FF6600">$skew_level</font>, <strong>level</strong>),
<strong><br>
right_key </strong>= <strong><font color="#0000FF">IF</font></strong>(<strong>right_key </strong>&lt;= <font color="#FF6600">$right_key</font>, <strong>right_key </strong>+ <font color="#FF6600">$skew_edit</font>, <strong><font color="#0000FF">IF</font></strong>(<strong>right_key </strong>&lt;= <font color="#FF6600">$right_key_near</font>, <strong>right_key </strong>- <font color="#FF6600">$skew_tree</font>, <strong>right_key</strong>))
<strong><font color="#0000FF"><br>
WHERE </font>right_key </strong>&gt; <font color="#FF6600">$left_key </font><strong><font color="#0000FF">AND </font>left_key </strong>&lt;= <font color="#FF6600">$right_key_near</font></p>
  <p>«амечани€ те же, что и при перемещении ветки вверх по дереву.</p>
  <p>Ќа этом в общем-то все, в итоге получаем только четыре основных 
действи€, основную сложность составл€ет подготовка переменных к 
перемещению узла.</p>
<div align="right"><i>—пасибо ћаксу (Maxim Matyukhin) за помощь в написании данной статьи</i></div><p></p></td>
</tr><tr>
<td><img src="article610_files/spacer.gif" height="8" width="1"></td>
</tr>
</tbody></table>
<br>
<!--  онец блока текста статьи -->

<table align="center" border="0" cellpadding="3" cellspacing="2" width="97%">
<tbody><tr>
<td align="left"><font class="kroshkatext">ї http://www.getinfo.ru/article610.html</font></td>
<td align="right"><font class="kroshkatext">ї 12.08.2004</font></td>
</tr>
</tbody></table>
<table align="center" bgcolor="#E8A11A" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td><img src="article610_files/spacer.gif" alt="" height="8" width="1"></td></tr>
<tr><td align="center"><script language="JavaScript">
<!--
  var NS = (navigator.appName == "Netscape");
  var VERSION = parseInt(navigator.appVersion);
  function MyPrint()
  {
   if(NS){ 
          window.print(); 
         }else{
               var WebBrowser = '<OBJECT ID="WebBrowser1" WIDTH=0 HEIGHT=0 CLASSID="CLSID:8856F961-340A-11D0-A96B-00C04FD705A2"></OBJECT>';
               document.body.insertAdjacentHTML('beforeEnd', WebBrowser);
               WebBrowser1.ExecWB(6, 2); // Use a 1 vs. a 2 for a prompting dialog box  
               WebBrowser1.outerHTML = "";
              }
  }
  if(VERSION > 3){ document.write('<form><input type="button" value="–аспечатать" title="–аспечатать статью" name="Print" class="addsubmit" onClick="MyPrint();"></form>'); }
//-->
</script><form><input value="–аспечатать" title="–аспечатать статью" name="Print" class="addsubmit" onclick="MyPrint();" type="button"></form></td></tr>
<tr><td><img src="article610_files/spacer.gif" alt="" height="8" width="1"></td></tr>
<tr><td style="font-family: Tahoma, Verdana, Helvetica; font-size: 10px; color: #999999;" align="right" bgcolor="#FFFFFF">©&nbsp;2003Ч2005. GETINFO.RU. ¬—≈ ѕ–ј¬ј «јў»ў≈Ќџ.&nbsp;</td></tr>
</tbody></table>








</body></html>